# 라이프 사이클의 개념
- 영유아에서 노년기까지 존재하는 인간의 생애 주기(Life Cycle)처럼, 리액트도 컴포넌트가 탄생한 순간부터 죽는 순간까지의 생애 주기를 가진다.
- 리액트에서 컴포넌트의 생애 주기는 다음과 같이 세 단계로 구분된다.
	1. **Mount (탄생)** - 컴포넌트가 화면에 처음 렌더링 되는 순간
	2. **Update (변화)** - 컴포넌트가 화면에 리렌더링 되는 순간
	3. **UnMount (죽음)** - 컴포넌트가 렌더링에서 제외되어 화면에서 제거되는 순간
- 컴포넌트의 라이프 사이클을 잘 이해하고 있으면, 원하는 타이밍에 컴포넌트가 특정 작업을 실행하도록 만들 수 있다.
	1. 마운트 되는 순간, 즉 컴포넌트가 화면에 처음 렌더링될 때 서버에서 데이터를 불러온다.
	2. 업데이트 될 때, 즉 컴포넌트가 리렌더링될 때 변경된 값을 콘솔에 출력한다.
	3. 언마운트 될 때, 즉 컴포넌트가 화면에서 제거될 때 컴포넌트가 사용하던 메모리를 정리한다.
- 이와 같이 컴포넌트의 라이프 사이클에 따라 다른 작업을 수행하는 것을 "**라이프사이클 제어**"라고 표현한다.
- 그리고 리액트에서는 `useEcffect`를 통해 라이프 사이클 제어를 쉽게 구현할 수 있다.

# useEffect를 통한 사이드 이펙트 제어
- 사이드 이펙트(Side Effect)는 우리말로 "부작용"이라는 뜻이지만, 리액트에서는 "부수적인 효과", "파생되는 효과" 정도로 해석할 수 있다.
- 더 구체적으로 말하자면, 리액트에서 "**사이드 이펙트**"란 **컴포넌트의 동작에 따라 파생되는 여러 효과**를 가리킨다.
- 예를 들어 컴포넌트 내부의 값을 변경(동작)할 때 콘솔에 변경된 값을 출력(사이드 이펙트)하거나, 컴포넌트가 마운트 됐을 때(동작) 콘솔에서 "Mount"를 출력(사이드 이펙트)하는 것도 동작으로 인한 사이드 이펙트가 일어난 것이다.
- 즉 **라이프 사이클을 제어하는 것도 결국 컴포넌트의 사이드 이펙트**라고 볼 수 있다.
- 그리고 `useEffet`라는 React Hook을 통해 사이드 이펙트를 제어할 수 있다.
- 즉 **`useEcffect`를 통해 어떤 값이 변경되었을 때 특정 코드를 실행하거나 라이프 사이클을 제어**할 수 있다.

# useEffect로 라이프사이클 제어하기
## 들어가기
```javascript
import "./App.css";
import { useState, useEffect } from "react"; // useEffect import

/*
useEffect 사용 시 기본적으로 컴포넌트 내부에서 값이 변경되었을 때 특정 동작이 수행되게 할 수 있다.
아래 코드에서는 `count` 값이 변경됐을 때 해당 값을 출력하도록 할 것이다.
*/
function App() {
const [count, setCount] = useState(0);
useEffect(() => {
console.log(`count: ${count}`);
}, [count]);
```
- useEffect도 React의 hook이기 때문에 import문으로 가져올 수 있다.
- useEffect 사용 시 기본적으로는 컴포넌트 내부에서 값이 변경되었을 때, 예를 들어 `count`라는 state 값이 변경됐을 때 원하는 동작이 수행되도록 만들 수 있다.
- **useEffect는 첫 번째 인수로 콜백함수를 받고, 두 번째 인수로 배열을 받는다.**
- 두 번째 인수로 받은 배열에 있는 값이 변경될 때마다 사이드 이펙트로써 첫 번째 인수로 받은 콜백함수를 실행한다.
- 배열에 있는 값에 따라 동작이 수행되기 때문에 **두 번째 인수로 받은 배열을 '의존성 배열(dependency array)', 줄여서는 deps라고 부른다**.
- deps는 배열이기 때문에 당연히 아래와 같이 값을 여러 개 넣을 수도 있다.
	```javascript
	const [count, setCount] = useState(0);
	const [input, setInput] = useState("");
	useEffect(() => {
	console.log(`count: ${count}, input: ${input}`);
	}, [count, input]);
	```
- 이벤트 핸들러가 아닌 useEffect를 사용하는 이유
	- 상태값을 변경할 때 사용하는 **`useState` 훅은 비동기로 동작**한다. 즉 함수 완료 시점이 함수 호출 시점보다 뒤다.
	- 따라서 이벤트 핸들러에 상태 변경 후 수행할 동작을 `useState` 밑에 작성하더라도, 실제로 `useState`가 호출되기 전에 해당 작업이 실행된다.
		```javascript
		const onClickButton = (value) => {
			setCount(count + value);
			console.lof(count);
		}
	    ```
		- 예를 들어 아래와 같이 값을 변경한 후 그 값을 출력하는 코드를 이벤트 핸들러에 작성 시 콘솔 출력문이 실행되는 순간에 setCount 함수는 호출되었을 뿐, 완료가 되지 않은 상태다.
		- 따라서 변경된 state의 값을 바로 사용해서 사이드 이펙트에 해당하는 부가적인 작업을 수행하려면, 이벤트 핸들러가 아닌 `useEffect`를 사용해야 한다.

## useEffect로 컴포넌트의 Mount 제어하기
- `useEffect`는 deps에 있는 값이 변경될 때 실행된다.
- 따라서 `useEffect(() => {}, []);`처럼 deps에 아무 값도 넣지 않으면 컴포넌트가 처음 Mount될 때 이후에는 다시는 실행되지 않는다. (Flutter의 StatefulWidget의 initState처럼 되는듯)
- 다시 말해, **컴포넌트가 최초로 마운트된 순간에만 딱 한 번 실행하고자 하는 동작일 경우, `useEffect`의 deps로 빈 배열을 넘겨주면 된다**.
## ## useEffect로 컴포넌트의 Update 제어하기
- `useEffect`의 두 번째 인수를 생략하면 첫 번째 인수로 넘겨준 콜백 함수는 컴포넌트가 Mount될 때는 물론이고, Update 시에도 매번 실행된다.
- 즉 `useEffect`의 deps를 생략하면 컴포넌트가 화면에 렌더링&리렌더링 될 때마다 콜백 함수가 실행된다.
- 만약 mount 되는 순간을 제외하고 update될 때만 `useEffect`를 실행하고자 한다면 `useRef`를 통해 컴포넌트의 마운트 여부를 체크하는 변수를 생성해 플래그로 사용하면 된다.
	```javascript
	const isMounted = useRef(false);
	useEffect(() => {	
		if (!isMounted.current) {
			isMounted.current = true;
			return; // Skip the first render	
		}
		console.log("componentDidUpdate");
	});
    ```
## useEffect로 컴포넌트의 UnMount 제어하기
- `useEffect`의수를 다음과 같이 전달해 주면 컴포넌트가 UnMount 될 때의 동작을 정의할 수 있다.
	- 첫 번째 인수(callback): 새로운 화살표 함수를 하나 더 만들어 return한다.
	- 두 번째 인수(deps): 빈 배열
	- 이때 useEffect의 콜백 함수가 반환하는 함수를 보통 정리 함수 내지 Cleanup 함수라고 부른다.
- deps를 빈 배열로 전달하면 `useEffect`가 반응할 상태값이 없기 때문에 컴포넌트가 Mount될 때만 실행되고, 그 이후에는 실행되지 않는다.
- 클린업 함수는 컴포넌트가 UnMouont 되거나, Effect가 다시 실행되기 전에 호출된다.
```javascript
useEffect(() => {
  console.log("Mount 또는 업데이트 시 실행");
  // Cleanup 함수 정의
  return () => {
    console.log("Unmount 또는 리렌더링 시 실행");
  };
}, []); // deps가 빈 배열인 경우 Mount/Unmount에만 반응

```
- 위 코드는 컴포넌트가 Mount 됐을 때 첫 번째 콜백함수를 (`console.log("Mount" 또는 업데이트 시 실행")`) 실행한다.
- 그리고 컴포넌트가 UnMount되거나, `useEffect`가 재실행되기 전에 React는 반환된 함수를 실행한다. (`console.log("Unmount 또는 리렌더링 시 실행)`)

# 번외 - 개발툴 (React Developer Tools) 설치
1. React Developt Tools 설치
2. 설정
	- 파일 URL에 대한 액세스 허용
	- 시크릿 모드에서 허용
	- 툴바에 고정
3. 리액트로 만들어진 화면에서 해당 툴이 활성화되며 아이콘 색이 주황색으로 바뀐다.
4. 개발자 도구의 상단 패널에서 꺾쇠 모양을 누르면 리액트 아이콘과 함꼐 `Components`와 `Profiler` 탭이 있는 걸 확인할 수 있다.
5. `Components` 탭에서는 각 컴포넌트의 props, hooks, rendered By, source 정보를 확인할 수 있다.
6. ` Components` 탭에 있는 톱니바퀴 버튼을 눌러 `Highlight updates when components render.`을 체크해주면 컴포넌트가 리렌더링되었을 때 해당하는 컴포넌트에 하이라이트가 적용된다.
	- 이 기능을 이용하면 불필요하게 리렌더링이 발생하는 컴포넌트를 알아내어 성능을 개선할 수 있다.