> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 8 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-8-widget-lifecycle-in-action-8dcb9abf3dcf)

> [!Question] 학습 목표
> `StatelessWidget`과 `StatefulWidget`의 **생명 주기(lifecycle)와 용례(use cases)**를 알아보자!

- StatelessWidget의 생명 주기는 생성자(constructor)로 시작한다. 이 생성자는 매개변수를 전달받을 수 있으며, 반드시 build 메서드를 재정의(override)해야 한다.
	![[StatelessWidget의 생명 주기.png|center|400]]
- `StatelessWidget`의 `build` 메서드는 일반적으로 아래와 같은 두 가지 상황에서 호출된다.    
    1. 위젯이 생성자로 인해 만들어졌을[생성되었을] 때 ([code example](https://dartpad.dev/?id=f2c30d4e1a390df9ef0ba7c075cd3e64))
        - 위젯이 트리에 추가되거나 새로운 `StatelessWidget` 객체가 생성될 때
        e.g. 초기 화면 로드 시 위젯이 생성되는 경우        
    2. 해당 위젯이 의존하는 [`InheritedWidget`](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-4-exploring-inheritedwidget-6161ddcb8c0a)이 변경되었을 때 ([code example](https://dartpad.dev/?id=e135cca903e4f8709b5ee074a9e25f56))
        - 더 정확히는 위젯이 InheritedWidget을 참조하고 있고, InheritedWidget의 상태가 업데이트되어 `updateShouldNotify`가 `true`를 반환하는 경우
        - 이때 해당 InheritedWidget을 의존하는 모든 자식 위젯의 `build` 메서드가 호출된다.
        e.g. `InheritedWidget`에서 제공하는 데이터가 변경되어 해당 위젯의 rebuild가 필요한 경우
- 2번 예제 코드를 기준으로, 버튼을 클릭했을 때
    

# StatefulWidget lifecycle

| **구분**                 | **StatelessWidget**                    | **StatefulWidget**                    |
| ---------------------- | -------------------------------------- | ------------------------------------- |
| **1. 생성 시**            | 위젯이 트리에 추가될 때                          | 위젯이 트리에 추가될 때                         |
| **2. 상태 변화**           | 없음                                     | `setState`가 호출될 때                     |
| **3. InheritedWidget** | 위젯이 의존하는 InheritedWidget이 변경될 때        | 위젯이 의존하는 InheritedWidget이 변경될 때       |
| **4. 부모 위젯 변화**        | 부모 위젯이 다시 빌드되면 해당 StatelessWidget도 빌드됨 | 부모 위젯이 다시 빌드되면 해당 StatefulWidget도 빌드됨 |
| **5. 재배치**             | 없음                                     | StatefulWidget이 다른 부모로 이동하면 다시 빌드됨    |

- **StatefulWidget에서 `build` 메서드가 실행되는 경우**
    1. 위젯이 생성될 때
        - StatefulWidget이 처음 트리에 추가되거나 생성될 때.
    2. `setState`가 호출될 때
        - `setState`는 상태 변화를 Flutter에 알리는 메서드입니다.
        - 호출 시 위젯의 `build` 메서드가 재실행되어 UI가 갱신됩니다.
    3. 위젯이 의존하는 InheritedWidget이 변경될 때
        - StatelessWidget과 마찬가지로, StatefulWidget이 InheritedWidget을 참조하고 있고, 해당 InheritedWidget이 변경되면 `build` 메서드가 호출됩니다.
    4. 부모 위젯이 `build`를 호출할 때
        - 부모 위젯이 다시 빌드되면, 자식 위젯의 `build` 메서드도 호출됩니다.
    5. 위젯 트리에서 재배치(reparenting)가 발생할 때
        - 동일한 StatefulWidget이 다른 부모로 이동하면 새로운 `Element`를 생성하며, `build`가 다시 호출됩니다.
- StatelessWidget과 유사하게, StatefulWidget의 생명 주기는 생성자와 반드시 override[재정의]해야하는 createState 메서드로 시작된다.
	![[StatefulWidget의 createState().png|center|150]]
- createState 메서드가 호출될 때 State 객체가 생성되고,해당 객체의 생명 주기는 아래 그림과 같다.
	![[StatefulWidget의 createState 메서드의 생명 주기.png]]
	- `build` 메서드와 `setState` 메서드는 [[2. StatefulWidget vs. StatelessWidget]]에서 다뤘으므로 아래에서는 그 외의 함수들을 다룬다.

# mounted property
- `createState` 메서드가 호출됨으로써 State 객체를 생성한 후에 `initState`를 호출하기 전에, 프레임워크는 **State 객체를 [BuildContext](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-3-understand-buildcontext-in-4-minutes-472af1df8e02)와 연결하기 위해 `mounted`라는 Boolean 속성을 `true`로 설정**한다.
- **mounted = true**는 **이 State 객체가 현재 위젯 트리에 포함되어[존재하고] 있음을 의미**한다.
- **`dispose` 메서드가 호출된 후**에는 State 객체가 더이상 위젯 트리 상에 존재하지 않으므로 **`mounted` 속성은 `false`**가 된다.
- `mounted` 속성이 `true`가 아닐 때 `setState`를 호출하는 건 에러다.
- 따라서 **항상 `setState` 호출 전에 mounted를 확인해야 한다**.
- 그래서 `setState` 메서드를 구현(implement)할 때도 아래와 같이 `mounted` 조건문으로 감싸주는 것이 베스트다.
    ```dart
    if (mounted) {
      setState(() {
        // do something
      });
    }
    ```

# initState method
- 객체가 위젯 트리에 삽입될(inserted) 때, 즉 `mounted` 속성이 `true`로 설정될 때, `initState` 메서드가 생성자 이후에 자동으로 실행된다(executed).
- `initState` 메서드는 **state 객체가 처음으로 생성될 때 딱 한 번 호출**된다.
- 이 메서드는 **클래스 생성자 이후에 단 한 번만 호출**되며, **State 객체가 처음 생성될 때만 실행**된다.
- 주의사항: **`BuildContext`를 이 메서드 내에서 사용할 수 없다.**
    - 예를 들어, `context.dependOnInheritedWidgetOfExactType()`와 같은 코드는 사용할 수 없다.
- 사용 예제
    1. 위젯 트리 상의 부모 위젯에 의존하는 속성들을 초기화한다.        
        ```dart
        class MyHomePageState extends State<MyHomePage> {
          late bool _isLoading;
          late int _counter;
          
          @override
          void initState() {
            super.initState();
            _isLoading = widget.isLoading;
            _counter = widget.counter;
          }
        ```
    2. HTTP 요청(requests)을 호출한다. → 맨 처음 화면 로드할 때 데이터 긁어오는 거 말하는 듯?
        ```dart
        late Future<Album> futureAlbum;
        @override
        void initState() {
          super.initState();
          futureAlbum = fetchAlbum();
        }
        Future<Album> fetchAlbum() async {
          final response = await http.get(Uri.parse('<https://jsonplaceholder.typicode.com/albums/1>'));
          if (response.statusCode == 200) {
            return Album.fromJson(jsonDecode(response.body));
          } else {
            throw Exception('Failed to load album');
          }
        }
        ```
    3. Stream, ChangeNotifier, 그리고 Listener와 같이 위젯에서 데이터를 바꿀 수 있는 다른 객체들을 구독할 때 사용한다.
        - 난 이 구독이라는 어휘가 직역하면 되게 이상한 거 같음.
        - 쭉 봤을 때 해당 객체들의 **변경 사항을 추적**할 수 있단 의미인 거 같음.
        - 찾아보니 **Flutter에서 구독이란 해당 객체가 변경될 때마다 알림을 받고, 그에 따라 필요한 작업을 수행하거나 UI를 업데이트하는 것**을 의미한다고 함.
        - 예를 들어 Stream을 구독하면 Stream에 새로운 데이터가 흘러 들어오는 걸 감지하고 반응할 수 있다.        
        ```dart
        late StreamSubscription streamSubscription;
        final scrollController = ScrollController();
        @override
        void initState() {
          super.initState();
          // Subscribe to streams (Stream 구독)
          streamSubscription = exceptionStream.listen((exception) => print(exception));  
          // Add listeners (Listener 추가)
          scrollController.addListener(listener);
        }
        ```

# didChangeDependencies method
- `didChangeDependencies` 메서드는 보통 아래 두 상황에서 호출된다.
    1. `initState` 메서드 바로 뒤에 호출된다.
    2. 해당 위젯이 의존하는 [`InheritedWidget`](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-4-exploring-inheritedwidget-6161ddcb8c0a)이 변경될 때 호출된다.
```dart
class _CounterWidgetState extends State<CounterWidget> {
  @override
  void initState() {
    super.initState();
    print('CounterWidget\\'s initState method is called');
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print('CounterWidget\\'s didChangeDependencies method is called');
  }

  // ...
}
```
[Full source code example](https://dartpad.dev/?id=7e2cbc5101b3e8bbb7c3f21f4f13741f)
- 위 코드의 full code를 실행해 보면 아래와 같이 출력된다. `initState` 메서드 바로 뒤에 호출되는 걸 확인할 수 있다.
    ```
    CounterWidget’s **constructor is called**
    CounterWidget’s **initState method is called**
    CounterWidget’s **didChangeDependencies method is called**
    CounterWidget’s **build method is called**
    ```
- `setState`가 호출되는 버튼을 클릭하면 아래와 같이 출력된다. 해당 위젯이 의존하는 `InheritedWidget`이 변경될 때 호출되는 걸 확인할 수 있다.
    ```
    Button clicked!. **Call setState method**
    CounterWidget’s **didChangeDependencies method is called**
    CounterWidget’s build method is called
    ```
- Use Case
    - 이 메서드는 `BuildContext`를 처음 사용할 수 있는 메서드로, 다음과 같은 작업에 적합하다.
        1. `context.inheritFromWidgetOfExactType`
        2. `Provider.of(context)`
        3. `MediaQuery.of(context)`
        4. `Theme.of(context)`
    - `InheritedWidget` 변경 시 네트워크 호출 등 리소스 집약적인 작업 수행
    - InheritedWidget이 업데이트될 때 네트워크 호출과 같이 리소스를 많이 잡아먹는(expensive) 동작을 호출할 때 사용될 수 있다.
# dirty property
- `setState` 메서드를 호출할 때 프레임워크는 위젯을 `dirty` 상태로 표시한다(marks).
- State 객체가가 dirty할 때마다, 즉 `dirty = true`일때마다, State 객체는 변동사항을 반영하기 위해 `build` 메서드를 호출해 UI를 갱신한다.

# didUpdateWidget method
- `didUpdateWidget` 메서드는 주로 부모 StatefulWidget이 `setState` 메서드를 호출할 때 발생한다.
    - 호출 시점: 부모 위젯이 동일한 `runtimeType`과 `Key`를 가진 새로운 위젯으로 업데이트되었을 때
        - Element가 `deactivated` 상태가 된 뒤 corresponding key를 찾아 재사용되는 경우에도, `didUpdateWidget` 메서드는 실행되지 않는다.
        - `didUpdateWidget`은 오직 부모 위젯이 동일한 `runtimeType`과 [Key](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-6-understand-keys-say-bye-to-ui-bugs-faac4f52a2b)를 가진 새로운 위젯으로 업데이트될 때 호출된다.
    - 동작: 프레임워크는 `State` 객체의 `widget` 속성(property)을 새로운 위젯으로 업데이트하고, 이전 위젯을 인수로 받아(refer to) 이 메서드를 호출한다.
    - **주의**: 이미 `build`가 호출되기 때문에 이 메서드 내에서 호출된 `setState`는 무의미하다.
- 사용 예제 : 위젯의 변화에 반응하도록 `didUpdateWidget` 메서드를 override한다.
    1. animation controller의 지속 시간(duration)을 업데이트 한다.
        ```java
        @override
        void didUpdateWidget(covariant AnimatedBox oldWidget) {
          super.didUpdateWidget(oldWidget);
          if (oldWidget.durationInSeconds != widget.durationInSeconds) {
            _controller.duration = Duration(seconds: widget.durationInSeconds);
            _controller.repeat(reverse: true);
          }
        }
        ```
        ![[didUpdateWidgnet 메서드를 활용한 애니메이션.gif]]
    2. tream 구독을 새 객체로 전환 ⇒ 이전 객체를 구독 해제하고, 새 객체 구독
        - 업데이트 된 위젯의 설정(configuration)이 객체를 교체하길 요구할 때, 이전(old) 객체를 Unsubscribe하고 새로운 위젯을 구독(subscribe)한다.
        ```dart
        StreamSubscription<int>? subscription;
        @override
        void didUpdateWidget(covariant Tile oldWidget) {
          super.didUpdateWidget(oldWidget);  
          if (widget.stream != oldWidget.stream) {
            subscription?.cancel(); // Unsubscribe from the old object
            subscription = widget.stream.listen( // subscribe to the new one
              (event) {
                print(event);
              },
            );
          }
        }
        
        // 이 코드에서 didUpdateWidget를 주석 처리하면 콘솔에 숫자가 출력되지 않는다.
        ```
        ![[Using the didUpdateWidget method.gif]]
		![[Not using the didUpdateWidget method.gif]]
- Chat GPT (복습할 때 읽어보기)
    - `didUpdateWidget` 메서드는 Flutter에서 위젯의 생명주기에 속한 메서드이다.
    - Flutter 앱에서는 위젯이 상태를 가질 수 있는데, 이러한 위젯들은 `StatefulWidget`이라고 한다.
    - 각 `StatefulWidget`은 상응하는 `State` 객체를 가지고 있다.
    - `State` 객체는 위젯의 상태를 관리하고, 위젯 트리에서 해당 위젯의 위치와 생명주기를 담당한다.
    - `didUpdateWidget` 메서드의 역할
        1. **위젯 업데이트 반응** : `didUpdateWidget`은 부모 위젯이 새로운 인스턴스로 업데이트되어 현재의 `State` 객체에 연결된 위젯이 변경될 때 호출된다. 이 메서드는 새로운 위젯과 이전 위젯을 비교하여 필요한 상태 업데이트나 리소스 해제 등의 작업을 수행할 수 있는 기회를 제공한다.
        2. **불필요한 `setState` 호출 방지** : `didUpdateWidget`이 호출된 후에는 Flutter 프레임워크가 `build` 메서드를 자동으로 호출한다. 따라서 `didUpdateWidget` 내부에서 상태 변경을 위해 `setState`를 호출할 필요가 없다. 이미 `build` 메서드가 호출될 예정이기 때문이다.
    - 사용 사례:
        - 상위 위젯에서 전달한 데이터가 변경될 때, 이 변경을 감지하고 그에 따른 특정 로직(데이터 처리, 애니메이션 시작 등)을 실행하고 싶을 때 `didUpdateWidget`을 사용할 수 있다.
        - 예를 들어, 위젯이 표시하는 데이터가 바뀌었는지 확인하고, 필요하다면 타이머를 재설정하거나 애니메이션을 다시 시작하는 등의 작업을 할 수 있다.
    - 요약 : `didUpdateWidget`은 위젯의 변경에 반응하여 상태를 업데이트하거나 리소스를 정리하는 데 사용되며, 이 메서드가 호출된 후에는 상태 변경을 위해 `setState`를 호출할 필요가 없다.

# deactivate method
- `deactivate` 메서드는 프레임워크가 State 객체를 트리에서 제거할 때마다 호출된다.
- **재사용 가능성**: 이 메서드 호출 후, 경우에 따라 `State` 객체가 트리의 다른 위치에 다시 삽입될 수 있다.
    - 가령 [`GlobalKey`](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-7-the-power-of-globalkey-6abf818225a0)를 사용해 State 객체를 포함하는 subtree가 트리의 한 위치에서 다른 위치로 옮겨질(grafted) 때를 예로 들 수 있다.
- 참고 코드 : [Full source code example](https://dartpad.dev/?id=cb20f7d2f0118c46ad45df11f4a20f22)
    - 위 참고 코드에서 버튼 클릭 시 `deactivate`만 호출되고, `dispose`는 호출되지 않는다.

# dispose method
- 이 메서드는 **State 객체가 위젯 트리에서 영구적으로 없어질 때 호출**된다.
    - **호출 시점**: 예를 들어, 화면이 스택에서 제거될 때 (the screen is popped off the stack)
- **주의 사항**: 이 메서드는 **리소스를 정리하고 메모리 누수를 방지하기 위해 반드시 구현**해야 한다.    
- 참고 코드 : [Full source code example](https://dartpad.dev/?id=ab986d63aa9de299cc9db251f5b271e5)
    ```java
    The widget with the key [GlobalKey#19b93] was deactivated
    The widget with the key [GlobalKey#85c33] was deactivated
    The widget with the key [GlobalKey#19b93] was disposed
    The widget with the key [GlobalKey#85c33] was disposed
    ```
    - 버튼을 누를 때 화면이 스택에서 제거되고, `deactivate`와 `dispose` 메서드가 모두 호출된다.
- 용례 : **객체에서 보유한(retained) 모든 리소스를 해제(release)**하기 위해 **`dispose` 메서드를 오버라이딩[재정의]** 해야 한다.
    - e.g. 활성화된 애니메이션 중지, 타이머 취소, 스트림 구독 취소, 리스너 제거    
    ```java
    late StreamSubscription streamSubscription;
    final scrollController = ScrollController();
    final textEditingController = TextEditingController();
    final streamController = StreamController();
    final timer = Timer(const Duration(milliseconds: 500), callback);
    final animationController = AnimationController(vsync: this);
    @override
    void dispose() {
      super.dispose();
      
      // Unsubscribe from streams
      streamSubscription.cancel();  
      // cancel timers
      timer.cancel();  
      // remove listeners
      scrollController.removeListener(listener);  
      // dispose controllers
      textEditingController.dispose();
      animationController.dispose();  
      // close StreamControllers
      streamController.close();
    }
    ```
- 만약 State의 `build` 메서드가 상태를 변경할 수 있는 객체(예: `ChangeNotifier`, `Stream`, 또는 다른 알림을 받기 위해 구독할 수 있는 객체)에 의존하는 경우, 다음과 같이 구독과 해제를 올바르게 처리해야 한다.    
    1. **`initState`에서 객체를 구독**
        - 객체의 상태 변화를 감지하기 위해 구독 설정.
    2. **`didUpdateWidget`에서 이전 객체 구독 해제 및 새 객체로 구독 전환**
        - 위젯이 업데이트될 때 이전 객체와 새 객체를 비교하고, _**필요하면**_ 새 객체로 전환.
    3. **`dispose`에서 객체 구독 해제**
        - 메모리 누수를 방지하기 위해 반드시 모든 구독을 해제하고, 리소스를 정리해야 한다.
- 참고 코드 : [*Stream example](https://dartpad.dev/?id=dd592cc01df44e1ea31476bc39e5c1d8) or [animation code example](https://dartpad.dev/?id=a0de832566603e87929c9c8521d316ed)*

# Conclusion
- 위젯의 생명 주기를 이해하면 다음과 같은 혼란스러운 오류를 피할 수 있다.
    - 왜 UI가 업데이트되지 않는지
    - 메모리 누수
    - 비정상적인 동작