> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 2 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-2-statefulwidget-vs-statelesswidget-15d195125d75)

# StatelessWidget, State, and the ‘build’ method
- 앞서 배웠듯 위젯은 Dart의 클래스다.
- 많은 위젯이 `StatelessWidget`이나 `StatefulWidget`을 상속 받아 만들어진다.
- 플러터(Flutter)에서 `StatelessWidget`과 `StatefulWidget` 모두 **`build` 메서드를 반드시 오버라이딩해야 한다.**
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    const MaterialApp(
      home: Scaffold(
        body: Center(
          child: CounterWidget(isLoading: true, counter: 7),
        ),
      ),
    ),
  );
}

class CounterWidget extends StatelessWidget {
  final bool isLoading;
  final int counter;

  // 생성자(Constructor)
  const CounterWidget({
    required this.isLoading,
    required this.counter,
  });

  // Flutter에서 build 메서드는 실제로 화면에 그려질 위젯 트리를 구성하는 역할
  // build 메서드는 반드시 Flutter의 Widget을 반환해야 하며,
  // 이 위젯은 이후에 Flutter의 렌더링 엔진에 의해 화면에 표시된다.
  @override
  Widget build(BuildContext context) {
    return isLoading ? const CircularProgressIndicator() : Text('$counter');
  }
}
```
![[UI = build(state).png|center|400]]
- 위 예제 코드에서 State는 build 메서드로 들어가는 데이터일 뿐이다.
- **$UI = build(state)$** : build 메서드는 state를 받아서 그에 따른 UI를 뱉어낸다는 점에서 수학에서의 함수와 비슷하다.
- **build 메서드는 `StatelessWidget` 객체를 초기화(initialize)할 때 호출된다.**

# StatefulWidget
- `StatefulWidget`을 상속 받은 위젯을 구현할 때, 반드시 `crateState` 함수를 오버라이딩 해야 한다.
- 그리고 해당 위젯을 제네릭으로 받는 `State<T>` 클래스를 상속받는 상태 클래스를 만들어야 한다.    
    ```dart
    class MyHomePage **extends StatefulWidget** {
      **@override**
      **State<MyHomePage> createState()** {
        // ...
      }
    }
    
    class MyHomePageState **extends State<MyHomePage>** {
      @override
      Widget build(BuildContext context) {
        // ...
      }
    }
    ```
- **`MyHomePage` 객체는 생성 시 `createState()`를 호출해 `MyHomePageState` 객체를 만든다.**
- **그리고 `MyHomePageState`은 초기화될 때 `build` 함수를 호출된다.**
- 이처럼 **커스텀 `StatefulWidget`을 만들 때는 `StatefulWidget`을 상속받는 클래스와 `State`를 상속받는 클래스 두 클래스를 필수적으로 구현**해야 한다.
- 코드 흐름 (The flow of code)
	![[StatelessWidget과 StatefulWidget의 코드 흐름.png|center|400]]
- `widget.state`
    ```dart
    class MyHomePage extends StatefulWidget {
      final bool isLoading;
      final int counter;  
      const MyHomePage({
        required this.isLoading,
        required this.counter,
      });  
      @override
      State<MyHomePage> createState() {
        return MyHomePageState();
      }
    }
    
    class MyHomePageState extends State<MyHomePage> {
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          body: Center(
            child: CounterWidget(
              isLoading: **widget.isLoading**,
              counter: **widget.counter**,
            ),
          ),
        );
      }
    }
    ```
    - `State` 클래스를 상속 받은 클래스는 `widget`이라는 변수를 가진다.
    - 위 예제 코드에서 `widget`은 `MyHomePage` 클래스의 인스턴스이다.
    - 따라서 `widget`을 통해 `MyHomePage`의 property인 `isLoading`과 `counter`에 접근할 수 있다.
- `StatelessWidget`과 `StatefulWidget`의 공통점과 차이점
    - 공통점 : 새로운 객체가 생성될 때(초기화될 때 → initialized) `build` 함수를 호출한다.
    - 차이점
        1. `StatefulWidget`은 새로운 객체 생성 때 뿐만 아니라, `setState` 메서드를 통해서 새로운 객체 생성 없이도 `build` 함수를 호출해 UI를 그릴 수 있다.
        2. `StatelessWidget`와 달리 `StatefulWidget`은 클래스 객체 생성 후, `build` 함수 실행 전에 호출되는 `initState` 함수를 통해 초깃값을 설정할 수 있다.

# setState method
- `State` 클래스 내 메서드이다.
- **`setState` 메서드를 통해 `build` 함수를 호출할 수 있다.**
- 값(value)는 상태(state)를 호출하고, 그에 따른 UI가 만들어진다. → **$UI = build(state)$**
- 즉 **UI를 바꾸기 위해서는 상태를 바꿔야 한다.**
- **때문에 상태는 `final` 키워드 대신 `State` 클래스 안에서 가변적 변수로 선언되어야 한다.**
- `initState` : 클래스 객체 생성 후, build 함수 실행 전에 호출해 초깃값을 설정할 수 있다.
	```dart
	class MyHomePageState extends State<MyHomePage> {
	  late bool _isLoading;
	  late int _counter;
	@override
	  void initState() {
	    super.initState();
	    _isLoading = widget.isLoading;
	    _counter = widget.counter;
	  }**
	  // ...
	  child: CounterWidget(
	   isLoading: _isLoading,
	   counter: _counter,
	  ),
	  // ...
    ```
	- 위 코드에선 `MyHomePage`에 전달된 값(value)들을 가져와서 `_isLoading`과 `_counter` 변수에 초깃값을 할당하기 위해 `initState` 함수를 사용했다.
	![[StatefulWidget의 기본 생애주기.png|center|400]]

# StatelessWidget vs. StatefulWidget
- 공통점
    1. `build` 함수를 가지고 있다.
    2. 공식(formula) : **$UI = build(state)$**
    3. 초기화할 때(initialization) `build` 함수를 호출한다.
- 차이점

| `StatelessWidget`                                 | `StatefulWidget`                                                                   |
| ------------------------------------------------- | ---------------------------------------------------------------------------------- |
| `State` 클래스, `initState` 메서드, `setState` 메서드가 없다. | `State` 클래스, `initState` 메서드, `setState` 메서드를 가지고 있다.                              |
| `build` 함수를 두 번 이상 호출하지 않기 때문에 변하지 않는다.           | `State` 객체가 `setState` 메서드로 `build` 함수를 두 번 이상 실행할 수 있기 때문에, 사용자와의 상호작용 시 변할 수 있다. |

```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: MyHomePage(isLoading: false, counter: 0),
    ),
  );
}

class MyHomePage extends StatefulWidget {
  final bool isLoading;
  final int counter;

  const MyHomePage({
    required this.isLoading,
    required this.counter,
  });

  @override
  State<MyHomePage> createState() {
    return MyHomePageState();
  }
}

class MyHomePageState extends State<MyHomePage> {
  late bool _isLoading;
  late int _counter;

  @override
  void initState() {
    super.initState();
    _isLoading = widget.isLoading;
    _counter = widget.counter;
  }

  @override
  Widget build(BuildContext context) {
    print('rebuild MyHomePage');
    return Scaffold(
      body: Center(
        child: CounterWidget(
          isLoading: _isLoading,
          counter: _counter,
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: onFloatingButtonClicked,
      ),
    );
  }

  void onFloatingButtonClicked() {
    print('Button clicked!. Call setState method');
    setState(() {
      _counter++;
      if (_counter % 2 == 0) {
        _isLoading = false;
      } else {
        _isLoading = true;
      }
    });
  }
}

/* CounterWidget은 상태가 변하지 않는 StatelessWidget이다. 하지만 MyHomePageState
   클래스의 build 메서드 내부에 CounterWidget이 존재해 setState가 호출될 때마다
   기존의 CounterWidget 객체가 새로운 속성값을 받는 새로운 객체로 교체된다.
   즉 MyHomePageState에서 setState로 build 함수를 호출할 때마다 UI가 바뀐다. */
class CounterWidget extends StatelessWidget {
  final bool isLoading;
  final int counter;

  const CounterWidget({
    required this.isLoading,
    required this.counter,
  });

  @override
  Widget build(BuildContext context) {
    return isLoading ? CircularProgressIndicator() : Text('$counter');
  }
}
```

# Which to use?
- `build` 함수를 재실행할 필요가 있는가 없는가로 구분한다.
- 즉 사용자와 상호작용 시 상태에 따라 UI가 바뀌어야 한다면 `StatefulWidget`으로 구현해야 한다.
- UI가 바뀔 필요가 없다면 `StatelessWidget`으로 구현하는 게 퍼포먼스 측면에서 유리하다.
- 주의점: 상태 변화에 따른 UI 변화가 없을 때는 StatelessWidget으로 구현하는 게 좋다. 포인트는 ‘UI에 변화가 있냐 없냐’이다.
- 예시: 체크박스도 유저의 클릭에 따라 상태가 바뀌고, 그에 따라 UI가 바뀌므로 StatefulWidget으로 구현해야 한다.