> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 6 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-6-understand-keys-say-bye-to-ui-bugs-faac4f52a2b)

# 버그 동작이 발생하는 위젯 예시
- 아래 나오는 예제 코드에서, 콘솔을 보면 버튼을 누를 때마다 박스 순서가 바뀌지만 UI는 변동이 없다.
![[key 관련 버그 동작 예시.gif]]
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(home: MyHomePage()));
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() {
    return _MyHomePageState();
  }
}

class _MyHomePageState extends State<MyHomePage> {
  final listTile = <Tile>[
    Tile(
      color: Colors.blue,
      name: 'blue Tile',
    ),
    Tile(
      color: Colors.red,
      name: 'red Tile',
    ),
  ];

  @override
  Widget build(BuildContext context) {
    // 동작 확인용 로깅을 위한 프린트문
    print('rebuild MyHomePage with listTile = ${listTile.map((e) => e.name)}');

    return Scaffold(
      body: Center(
        child: Row(
          children: listTile,
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: swapTwoTileWidget,
        child: Icon(Icons.swap_horiz),
      ),
    );
  }
  
  // 두 타일의 위치를 바꾸기 위한 함수
  void swapTwoTileWidget() {
    setState(() {
      listTile.insert(1, listTile.removeAt(0));
    });
  }
}

class Tile extends StatefulWidget {
  final Color color;
  final String name; // Debugging을 위한 name 속성

  Tile({
    required this.color,
    required this.name,
  });

  @override
  _TileState createState() => _TileState();
}

class _TileState extends State<Tile> {
  Color? _color;

  @override
  void initState() {
    super.initState();
    _color = widget.color;
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      color: _color,
      width: 100,
      height: 100,
    );
  }
}
```

# Scenario: Row 안에 있는 사각형 모양의 두 위젯 자리 바꾸기
- 어떤 위젯이 `StatefulWidget`이라면, Element는 `widget`이라는 변수를 통해 `StatefulWidget`에 대한 참조를 가지며, state라는 변수를 통해 `State`에 대한 참조를 가진다.
    - Element**는** StatefulWidget과 State를 연결하는 매개체로 작동한다.
    - **widget 참조는 새 위젯으로 업데이트되지만, state 참조는 동일하게 유지된다.**
	    ![[key 관련 예시 위젯 트리와 엘레멘트 트리.png|center|400]]
- 가장 상위에 있는 `MyHomePage`를 rebuild하기 위해 `setState`를 호출할 때, Flutter는 Element tree를 타고 내려가며 이전 위젯과 새 위젯을 비교한다.
- 이 경우엔 이전의 Red Tile과 새 Blue Tile이 같은 Type인지, 그리고 이전의 Blue Tile과 새 Red Tile이 같은 Type인지 비교한다.
    - Flutter의 Widget은 불변 객체다. 따라서 상태 변화나 재빌드가 발생하면 기존 위젯 객체를 수정하지 않고 새로운 위젯 객체를 생성한다.
    - 이때 새로운 객체의 타입(Type)이 이전 객체의 타입과 같으면 Element는 기존 Element에 연결한다.
    - 기존 Element에 연결되는 과정에서 위젯에 대한 참조만 업데이트되고 상태(state)는 유지된다.
    - 만약 새로운 객체와 이전 객체의 타입이 다르다면, 기존 Element와 관련된 트리가 폐기되고 새로언 Element와 그에 따른 트리가 생성된다.
    - 따라서 위젯의 참조와 상태 모두 변하게 된다.
- Blue Tile Element는 새 Red Tile 위젯을 가리키기 위해 위젯 참조를 업데이트하고, red Tile Element는 새 Blue Tile 위젯을 가리키기 위해 위젯 참조를 업데이트 한다. 두 타일은 상태만 다르고 타입은 결국 동일한 `Tile` 타입이다.
- 결과적으로 Element는 widget 변수의 참조만 바꾸고 변수 state의 참조는 바꾸지 않는다. 즉 위젯 두 개는 서로 교체하더라도, 두 상태는(State) 는 교체되지 않는다.
	![[key 관련 예시 전후 비교.png|center|400]]
- 그 사이 Tile 클래스의 build 함수는 Tile Element의 색을 보여주기 위해 TileState 클래스의 _color 변수를 사용한다.
	- TileState는 `initState`에서 초기화된 `_color` 변수를 사용한다.
	- Element는 기존 state를 유지하므로, `_color`는 교체 후에도 여전히 이전 상태를 보여준다.
	- 이 때문에 두 타일의 위치가 바뀌더라도 색상은 바뀌지 않는다.
- 그래서 element의 state 변수가 바뀌지 않을 때 색깔도 안 바뀌는 것이다. 바로 이 문제를 key로 해결할 수 있다(This is also when comes to save the day.)
- 그래서 element의 state 변수가 바뀌지 않을 때 색깔도 안 바뀌는 것이다. 바로 이 문제를 key로 해결할 수 있다(This is also when comes to save the day.)
	![[key 관련 예시 UI 버그 구조.gif|center|400]]
- Key 예고
    - Flutter의 **`Key`**는 Element Tree에서 **위젯을 고유하게 식별**하는 데 된다.
    - 각 Tile에 고유한 **Key를 지정하면, Element Tree가 두 위젯을 서로 다른 것으로 인식**하여 새로운 Element를 생성한다.
    - 이렇게 하면 **`_color` 변수도 새로 초기화되며 색상이 제대로 바뀌게 됩니다**.

# Key의 개념 (What is `key`?)
> [!Quote]- A Key is an identifier for Widgets and Elements.
> Key는 Widget과 Element를 식별하는 데 사용되는 식별자다.
- Flutter에서 Key의 계층 구조
	![[Flutter에서 Key의 계층 구조.png|center|500]]
- 여러 키가 있지만 이 파트에서는 `LocalKey` 위주로 공부해보자. (`GlobalKey`는 다음 파트에)
    - 실제로 `ValueKey`, `ObjectKey`, `UniqueKey`로도 위 버그를 해결할 수 있다.
    - 세 개의 로컬 키에 대한 비교도 말미에 다루겠지만, 일단은 `ValueKey`부터 살펴보자.
- **`ValueKey`의 개념**
    - `ValueKey`는 특정 값으로 자신을 식별하는(identify) 키이다.
    - **두 `ValueKey<T>`가 동일한 값(== 연산자operator)을 가지면 동일하다고 간주**된다.
        - Flutter에서 **`ValueKey<T>`**는 제네릭 타입 **`T`**의 인스턴스를 키 값으로 사용한다.
        - 이 키는 특정 위젯을 식별하는 데 사용되며, 두 **`ValueKey<T>`** 객체가 동일한 것으로 간주되려면 그들의 값이 동일해야 한다.
        - 즉, == 연산자를 사용하여 두 키의 값이 같은지 비교한다.
        - 만약 두 **`ValueKey<T>`** 객체의 값이 같다면, 그들은 동일한 것으로 간주되어 동일한 위젯을 식별하게 된다.
        - 반대로, 값이 다르면, 두 키는 서로 다른 것으로 간주되어 서로 다른 위젯을 식별하게 된다.
        - 이러한 특성은 Flutter의 위젯 트리에서 특정 위젯을 효율적으로 식별하고 관리하는 데 중요한 역할을 한다.
    - **같은 부모를 가진 요소들 간에는 Key가 고유해야 하며, 중복된 ValueKey를 사용하면** `Exception: Duplicate keys found` **에러가 발생**한다.
    - 또한 동일한 Valuekey를 가진 두 위젯을 하나의 열(Column 위젯)이나 행(Row 위젯)에서 함께 사용할 수 없다.
        - `Column` 위젯과 `Row` 위젯은 자식 위젯들을 받아들이는 부모 위젯 역할을 한다.
        - 이때 모든 자식 위젯은 같은 부모(`Column` 또는 `Row`) 아래에 존재하므로, 같은 부모를 공유하는 자식 위젯들 간에는 Key가 고유해야 한다.
        - 부모는 자식 위젯을 Key로 식별하여 Element Tree에서 어떤 자식 위젯이 어떤 Element와 연결되는지 결정한다.
        - 동일한 Key를 가진 두 자식이 존재하면, Flutter는 두 자식 중 어느 것이 어떤 Element에 대응해야 하는지 알 수 없다.
        - 이로 인해 Flutter는 `Duplicate keys found` 예외를 던진다.
- `ValueKey`를 활용해 Tile 구별하기
    1. Key를 활용하기 위해 `Tile` 클래스의 생성자에 `key` 매개변수(parameter)를 추가한다. 이는 `ValueKey`를 만들어서 Tile 객체(Object Tile)에 전달한 것이다.
        ```dart
        Tile({
          required this.color,
          required this.name,
          **super.key, //NEW**
        })
        ```
    2. 앞서 살펴봤듯 같은 부모를 가진 요소들 간에는 Key가 고유해야 하며, 중복된 ValueKey를 사용해선 안 된다. 따라서 Blue Tile과 Red Tile에는 서로 다른 값의 ValueKey를 생성한다.
        ```dart
        final listTile = <Tile>[
            Tile(
              color: Colors.blue,
              name: 'blue Tile',
              **key: ValueKey(1), // NEW**
            ),
            Tile(
              color: Colors.red,
              name: 'red Tile',
              **key: ValueKey(2), // NEW**
            ),
        ];
        ```

# How Flutter works **under the hood**(Beneath the surface; in its internal workings)
## 재빌드 시 Element의 비교 시나리오
- 위젯이 다시 빌드될 때 `Element`는 이전 위젯과 새 위젯의 `Type`뿐만 아니라 `Key`도 비교한다.
- 비교 과정에서 세 가지 시나리오가 존재할 수 있다.
    1. 둘 다 `null`인 경우를 포함해서, 만약 `Type`과 `Key` 모두 동일하다면 `Element`는 참조를 업데이트하여 새 위젯을 가리킨다.
    2. `Type`_**만**_ 동일할 경우 Element는 비활성화(deactivated)된다.
    3. 만약 타입이 서로 다르면, 해당 엘리먼트는 폐기(disposed)된다.
## `dispose` vs `deactivate`
- **dispose** : Element가 **Element tree에서 영구적으로 제거**된다.
- **deactivate** : Element가 **제거될 수도 있지만, 반드시 그런 건 아니다**. 계속 살아있을 수도 있다.
## Key가 적용된 Flutter의 동작 방식
### 버그가 발생한 이유
![[deactivated element.gif|center|400]]
- 스와핑 함수를 호출한 뒤에, blue Tile Element와 red Tile Element는 새 위젯과 이전 위젯을 비교하기 시작한다.
- 두 Tile Element가 동일한 타입이라도, Key가 동일하지 않기 때문에 두 Elements는 비활성화될 뿐(deactivated), 제거되진(disposed) 않는다.
### 비활성화된 후
- 비활성화된 Element는 Row 내에서 Key가 일치하는 새 위젯을 찾눈다.
- 일치하는 새 위젯을 찾으면, 해당 Element는 새 위젯을 참조하도록 업데이트되고 위치를 교환한다.
- 이 과정에서 **State도 교환되므로 UI가 올바르게 업데이트된다**.
### Key가 일치하지 않을 경우
- **Key가 일치하는 위젯을 찾지 못하면, 해당 Element는 폐기(disposed)되며, Element Tree에서 영구적으로 제거된다.**
### key가 모두 일치하는 위젯을 찾아낸 경우
![[element가 key가 일치하는 위젯을 찾은 경우.gif|center|400]]
- 두 Element 모두 일치하는 위젯을 찾아내서 서로 자리를 바꾸게 된다. 두 개의 상태 또한 서로 바뀌게(swapped) 된다.
- 이게 바로 UI가 상태를 올바르게 바꿔서 버그를 고치는 방식이다.

# ValueKey vs ObjectKey
- `ValueKey` : [**== 연산자**](https://api.dart.dev/stable/2.9.2/dart-core/Object/operator_equals.html)를 사용해 두 key의 값(value)을 비교한다. 동일한 값이면 동일한 Key로 간주한다.
- `ObjectKey` : [**identical function**](https://api.dart.dev/dart-core/identical.html)(함수)을 사용해 두 Key 객체가 동일한 참조를 가리키는지 체크한다. 동일한 객체 참조만 같은 Key로 간주한다.

# UniqueKey
> [!Quote]- A Key(UniqueKey) is that is only **equal to itself**.
> UniqueKey는 **자기 자신과만 동일**한 Key이다.
- 이름에서 알 수 있듯, 동일한 UniqueKey는 존재하지 않는다. 즉 UniqueKey는 서로 겹치지 않는다.
- 모든 Key가 고유하기 때문에 `Duplicate keys found` 예외가 발생하지 않는다.
- 하지만 유니크 키를 쓰는 게 안 좋은 상황도 있다.
- 예를 들어, `TextField`과 `FloatingActionButton`을 가진 `Column` 위젯이 있고, 버튼을 누를 때마다 가 다시 빌드된다고 해보자.
- ![[ValueKey와 UniqueKey.gif|center|400]]
- [**Using ValueKey 코드 링크](https://dartpad.dev/?id=b9ed666dc9cf1e70b0f6e566477b789c) / [Using UniqueKey 코드](https://dartpad.dev/?id=4c05fcd74c4a34e5b863953ae91064fb)**
- ValueKey랑 달리 UniqueKey는 `TextField`가 다시 빌드될 때 새로운 `UniqueKey`가 생성되고, 이는 무조건 이전 Key와 다르기 때문에 일치하는 `TextField` 위젯을 찾을 수 없게되면서 Element가 트리에서 폐기되고 새로 생성된다.
- 이로 인해 새로운 Element가 인스턴스화되고, TextField의 모든 텍스트를 지워버린다.