> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 7 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-7-the-power-of-globalkey-6abf818225a0)

# What is GlobalKey?
- `key`는 `LocalKey`와 `GlobalKey`를 서브클래스로 가지고 있다.
- 앞서 배웠듯, `LocalKey`는 동일한 부모를 가진 요소들 사이에서 고유해야(unique) 한다.
- **GlobalKey**는 **앱 전체에서 고유한 키**다.
- 우리는 `GlobalKey`를 활용해 `Element` in question에 접근해 해당 `Element`의 State와 Widget을 가져올(retrieve) 수 있다.
    we can find and access the Element in question and retrieve its State and Widget.
- 우리는 **`GlobalKey`를 활용해 특정 `Element`를 찾아서 접근해 해당 `State`와 `Widget`을 가져올** 수 있다.
- 실제로 `GlobalKey`로 선언된 Widget의 경우, **`currentWidget`을 통해 쉽게 위젯의 참조를 가져올** 수 있고, 만약 해당 위젯이 **StatefulWidget**이라면, **`currentState`**를 통해 **상태(State)에도 접근**할 수 있다.

# What can GlobalKey do?
- 앞서 우리는 `context`를 배우면서 `No Scaffold ancestor could be found starting from the context that was passed to Scaffold.of()` 에러를 다뤘었다. ([source code](https://dartpad.dev/?id=71d9edbd335726c3bcc8b87abf8acd6d))
- 당시 `Builder` 위젯을 사용하거나 `FloatingActionButton`을 따로 `MyButtonWidget`으로 빼서 해결했었는데, `GlobalKey`를 사용해서도 해결할 수 있다. → [노션 링크](https://www.notion.so/3-Understand-BuildContext-in-4-minutes-bc5ab5dd4d604f75af9a1b20649fa2e4?pvs=21)
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: MyHomePage(),
    ),
  );
}

/*
**1. GlobalKey 생성 및 Scaffold에 전달**
   **Scaffold는 StatefulWidget이므로, ScaffoldState라는 상태를 가지고 있다.
   따라서 GlobalKey를 생성하고 Scaffold에 key로 전달해야 한다.
   
2. GlobalKey를 사용해 Scaffold의 상태 찾기
   Scaffold를 찾기 위해 scaffoldKey를 사용한다.
   그리고 currentState를 통해 Scaffold의 State를 가져온 후
   showBottomSheet를 호출한다.**
*/
class MyHomePage extends StatelessWidget {
  **final scaffoldKey = GlobalKey<ScaffoldState>(); // 1번**

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      **key: scaffoldKey, // 1번**
      floatingActionButton: FloatingActionButton(onPressed: () {
        **~~Scaffold.of(context).showBottomSheet(~~**
        **scaffoldKey.currentState?.showBottomSheet( // 2번**
          **(context) => Text('Flutter From Zero to Hero'),**
        **);**
      }),
    );
  }
}
```
- `GlobalKey`는 이외에도 context 없이 화면 전환하기(navigation), 위젯의 너비(width) 가져오기, 높이(height) 가져오기, 좌표(coordinates) 가져오기 등 다양한 응용법(application)이 있다.

# The power of GlobalKey
- 지난 시간에 두 타일의 색깔을 바꾸는 코드의 난이도를 올리기 위해 두 가지 요구사항을 추가해보자.
    - 타일의 색을 빨강과 파랑으로 제한하지 않고, 랜덤으로 바꾸어야 한다.
    - `Tile` 위젯을 `Padding`으로 감싼다.
```dart
import 'dart:math';
import 'package:flutter/material.dart';

void main() {
  runApp(MaterialApp(home: MyHomePage()));
}

class MyHomePage extends StatefulWidget {
  @override
  _MyHomePageState createState() {
    return _MyHomePageState();
  }
}

class _MyHomePageState extends State<MyHomePage> {
  **// Tile을 Padding으로 감싸기 전에는 랜덤한 색상이 처음에 세팅된 후 타일의 위치만 계속 바뀐다.**
  **// 하지만 Padding으로 감싸고 나면 버튼 클릭 시 두 타일의 위치가 바뀔 때마다 색상이 랜덤하게 바뀐다.**
  final listTile = **~~<Tile>~~**[
    **Padding(**
      **padding: EdgeInsets.zero,**
      **child:** Tile(
        key: ValueKey(1),
      ),
    **),**
    **Padding(**
      **padding: EdgeInsets.zero,**
      **child:** Tile(
        key: ValueKey(2),
      ),
    ),
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Row(
          children: listTile,
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: swapTwoTileWidget,
        child: Icon(Icons.swap_horiz),
      ),
    );
  }

  void swapTwoTileWidget() {
    setState(() {
      listTile.insert(1, listTile.removeAt(0));
    });
  }
}

class Tile extends StatefulWidget {
  Tile({
    super.key,
  });

  @override
  _TileState createState() => _TileState();
}

class _TileState extends State<Tile> {
  Color? _color;

  @override
  void initState() {
    super.initState();
    **_color = generateRandomColor(); // 1-2. 랜덤 색상 설정**
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      color: _color,
      width: 100,
      height: 100,
    );
  }
}

**// 1-1. 랜덤 색상을 만드는 함수**
**Color generateRandomColor() {
  final Random random = Random();
  return Color.fromRGBO(
      random.nextInt(255), random.nextInt(255), random.nextInt(255), 1);
}**
```
- 내부 동작을 알아보기 위해 지난 시간에 배운 Eelement와 Key에 대해서 더 깊게 파고 들어가보자.
- **Padding으로 Tile 위젯을 감싼 후의 Widget Tree와 Element Tree 구조**
    - 타일을 교체하면, Key가 일치하지 않아 두 `Element`가 비활성화(deactivated)된다.
    - Flutter는 Row의 자식 중에서 Key가 일치하는 요소(element)를 찾으려고 한다.
    - 그러나 Flutter는 같은 트리 레벨에서만 일치하는 Key를 찾는다. 이때 “**같은 트리 레벨**”이란, **같은 부모를 공유하는 자식 위젯들**을 의미한다.
    - 따라서 Flutter는 `Padding`으로 인해 다른 레벨(→ 한 단계 낮은 레벨)에 위치하게 된 `Tile`을 찾지 못하게 된다.
	    ![[element는 트리 내 동일 계층에서 key를 탐색한다.png|center|400]]
    - 결과: 일치하는 `Element`를 찾을 수 없으므로 새로운 `Element` 인스턴스가 생성되고, 새로운 상태(State)가 초기화된다. 따라서 따라서 랜덤 색상이 다시 설정된다.
- 해결 방법: `ValueKey` 대신 `GlobalKey`를 사용하면 문제를 해결할 수 있다.    
    ```dart
    final listTile = [
        Padding(
            padding: EdgeInsets.zero,
            child: Tile(
              key: GlobalKey(), // HERE
            ),
        ),
        Padding(
            padding: EdgeInsets.zero,
            child: Tile(
              key: GlobalKey(), // HERE
            ),
        ),
    ];
    ```
    - GlobalKey는 앱 전체에서 고유하며, **Key를 검색할 때 트리의 특정 레벨에 제한되지 않는다**.
    - GlobalKey를 통해 Flutter는 트리의 어느 레벨에 있든 Key가 일치하는 위젯을 찾아 Element와 매칭한다.
    - 따라서 기존의 `Element`와 `State`를 재사용하여 타일의 색상이 유지된다.

# GlobalKey is a double-edged sword
- GlobalKey는 이해 후 잘 활용할 수만 있다면(can put it to good use) 강력한 무기가 될 것이다.
- 예를 들어, Counter의 State가 전체 앱을 가로질러 이동할 수 있도록 만들어 어디서든 CounterState에 접근할 수 있게 할 수도 있다. 하지만 이런 동작이 정말 좋은걸까?
- GlobalKey는 강력한 만큼 위험하기에 큰 장점이 될 수도 있지만 큰 단점이 될 수도 있다.
- 그리고 사실 대부분의 문제는 GlobalKey를 사용하지 않고도 해결할 수 있다.
- 위 문제 또한 [Flutter에서 권장하는 상태 관리 방식](https://docs.flutter.dev/data-and-backend/state-mgmt/options) 중 하나를 사용해 해결할 수 있다.
- **`GlobalKey`는 전역 변수와 같으니, 남발하지 말고 적재적소에 사용하자.**

# Rule of thumb for GlobalKey
> [!Note]- (영어 공부) rule of thumb
> : a practical and approximate way of doing or measuring something
> : a broadly accurate guide or principle, based on experience or practice rather than theory
> : 과학적이거나 수학적인 근거가 아닌, 대상에 대하여 통상적인 경험에 비춰보았을 때 대략적인 경향 및 양상을 띠는 규칙
1. **`LocalKey` 규칙**
    - 조건: 같은 부모 위젯을 공유하는 경우, 두 위젯이 동일한 `LocalKey`를 가질 수 없다.
    - 동작 방식: `LocalKey`는 부모 위젯 수준에서의 고유성을 보장한다.
    - e.g. `Row`나 `Column`의 자식 위젯들이 `LocalKey`를 통해 고유하게 식별된다.
2. **`GlobalKey` 규칙**
    - 조건: 앱 내에서 두 위젯이 동일한 `GlobalKey`를 가질 수 없다.
    - 동작 방식: `GlobalKey`는 앱의 어느 위치에서든 동일한 Key를 사용해 위젯을 고유하게 식별할 수 있다.
    - 특징1: 따라서 `GlobalKey`는 `LocalKey`보다 더 넓은 범위의 고유성을 제공한다.
    - 특징2: GlobalKey는 위젯의 **`Element`, `State`, `Widget`에 접근**할 수 있는 강력한 기능을 제공한다.
- **플러터는 전역 - 지역 구분이 함수나 그런 게 아니고 부모 - 자식인 듯. 아무래도 위젯 기반이라 그런가 봄.**
```dart
final globalKey = GlobalKey();
late final listTile = <Tile>[
    Tile(
      key: globalKey,
    ),
    Tile(
      key: globalKey,
    ),
  ];
```
- 이와 같은 코드는 작성하지 마라.
- 이는 다음과 같은 에러를 발생시킨다.
    `Multiple widgets used the same GlobalKey`

# 예제 from me
```dart
// 자식 위젯 - 데이터 테이블
class BuildAppDataTable extends StatefulWidget {
  // 생략
  **final GlobalKey<BuildAppDataTableState>? key;**
  **final List<dynamic> rawData;**

  const BuildAppDataTable({
    **this.key,**
    **required this.rawData,**
    // 생략
  }) : super(key: key);
  @override
  State<BuildAppDataTable> createState() => BuildAppDataTableState();
}

class BuildAppDataTableState extends State<BuildAppDataTable> {
  late List<bool> selected;

  List<Map<String, dynamic>> **getSelectedRowData()** { **// 부모 위젯에서 접근하려는 메서드**
    List<Map<String, dynamic>> selectedRowsData = [];
    for (int i = 0; i < selected.length; i++) {
      if (selected![i]) {
        selectedRowsData.add(widget.rawData[i]);
      }
    }
    return selectedRowsData;
  }
// 생략
}

// 부모 위젯 - DelvInPage 입고 등록 페이지
class DelvInPage extends StatefulWidget {
  const DelvInPage({Key? key}) : super(key: key);

  @override
  DelvInPageState createState() => DelvInPageState();
}

class DelvInPageState extends State<DelvInPage> {
  WorkingTagBloc? workingTagBloc;
  late List<bool> selectedRows;
  List<Map<String, dynamic>> dataToSave = [];
  **final GlobalKey<BuildAppDataTableState> dataTableKey = GlobalKey();**

  // 자식 위젯(데이터 테이블)에 있는 메서드 getSelectedRowData()를 사용하는 부분
  List<Map<String, dynamic>> _onSavePressed() {
    List<Map<String, dynamic>> selectedData =
        dataTableKey.currentState?.**getSelectedRowData**() ?? [];
    print("Selected Data: $selectedData");
    return selectedData;
  }

  // 생략
  @override
  Widget build(BuildContext context) {
  // 생략
    return DefaultScaffold(
      // 생략
              BuildAppDataTable( // 자식 위젯(데이터 테이블) 생성 부분
                **rawData: dataToSave,**
                **key: dataTableKey, // 글로벌 키를 자식 위젯에 넘겨 준다.**
                // 생
                onCheckboxChanged: (bool? value, int index) {
                  setState(() {
                    selectedRows[index] = value!;
                  });
                },
              ),
      // 생략
    )
  }
}
```
- ANASA WARE Mobile - **`DelvInPage`에 `GlobalKey<BuildAppDataTableState>`를 사용하는 이유**
- **TL;DR** : `DelvInPage` 상태와 `BuildAppDataTable` 상태 사이의 연결을 만들기 위해서
    - 이 연결을 통해 `DelvInPageState`에서 `BuildAppDataTableState`의 메서드와 속성에 접근할 수 있다.
    - 위 코드의 경우 `BuildAppDataTable`에서 선택된 행 데이터에 접근하려고 사용한다.
- **GlobalKey의 사용 목적**
    - Flutter에서 `GlobalKey`는 **애플리케이션의 다른 부분에서 위젯의 상태에 접근할 필요가 있을 때 사용**된다.
    - 위젯 계층 구조에서 `DelvInPage`는 `BuildAppDataTable`의 부모 위젯이다.
    - 자식 위젯인 `BuildAppDataTable`에 `GlobalKey`를 할당함으로써, **부모 위젯의 상태 클래스**인 `DelvInPageState`**에서 자식 위젯의 상태**(`BuildAppDataTableState`)**에 접근할 수 있다.**
    - 선택된 행 데이터에 접근하기: `BuildAppDataTableState`에는 선택된 행의 데이터를 반환하는 `getSelectedRowData()` 메서드가 있다.
    - 해당 **자식 위젯의 메서드를 부모 위젯**인 `DelvInPageState`**에서 호출**하려면 `BuildAppDataTableState`에 대한 참조가 필요하다. 이것이 `GlobalKey`가 유용한 이유이다.
- **데이터에 직접 접근하지 못하는 이유**: Flutter의 상태 관리는 부모 위젯이 자식의 상태에 직접 접근할 수 없도록 작동한다. 이는 Flutter가 단방향 데이터 흐름 모델을 사용하기 때문이다. `GlobalKey`는 필요할 때 이 제한을 우회하는 방법이다.
- **사용법**: `DelvInPage`에서 `BuildAppDataTable`의 인스턴스를 생성할 때, `dataTableKey`를 전달한다. 나중에 `DelvInPageState`에서 선택된 행 데이터에 접근할 필요가 있을 때, 이 키를 사용한다.
    ```dart
    List<Map<String, dynamic>> selectedData = dataTableKey.currentState?.getSelectedRowData() ?? [];
    ```
    - 위 코드는 `dataTableKey`를 사용하여 `BuildAppDataTable`의 `currentState`에 접근한 다음 `getSelectedRowData` 메서드를 호출한다.
- 대체 접근법: `GlobalKey`는 유용하지만, 드물게 사용하는 것이 좋다. `GlobalKey`의 과도한 사용은 복잡하고 유지 관리하기 어려운 코드로 이어질 수 있다. 애플리케이션의 아키텍처에 따라, 상태를 관리하는 다른 방법이 있을 수 있다. 예를 들어 `Provider`, `Bloc` 또는 Flutter가 지원하는 다른 상태 관리 솔루션을 사용할 수 있다.
- 요약하자면, 이 시나리오에서 **`GlobalKey`**를 사용하는 이유는 부모 위젯에서 자식의 상태의 메서드에 접근하여 UI의 컴포넌트 간 더 복잡한 상호 작용을 가능하게 하는 것이다. 하지만 항상 더 간단하거나 적절한 상태 관리 솔루션이 있는지 고려해야 한다.