> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 4 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-4-exploring-inheritedwidget-6161ddcb8c0a)

# Scenario
- lesson2에서 MyHomePage의 데이터를 자식 위젯인 CounterWidget에 넘기기 위해서 CounterWidget에 MyHomePage와 동일한 생성자를 작성해야 했었다.
![[Passing state down.png|center|400]]
- 자식 위젯에 상태를 넘기기 위해 동일한 생성자를 작성하는 걸 “Passing state down”이라고 부른다.
![[Passing state down 구조도 1.png|center|500]]
- 카운터를 화면 정중앙에 위치시키는 Center 위젯을 별도의 MyCenterWidget으로 뽑아냈다고 해보자.
- 그러면 MyHomePage에서 CounterWidget으로 아래로 전달된 데이터를 받기 위해 또 counter와 isLoading 속성을 가진 생성자를 만들어야 한다.
![[Passing state down 구조도 2.png|center|500]]
- 이렇게 되면 문제 두 가지가 발생한다.
    1. `MyHomePage`와 `CounterWidget` 간 거리가 멀어질수록 그 사이에 존재하는 위젯 수만큼 생성자가 늘어나게 된다.
    2. `MyHomePage`가 `setState` 함수를 호출할 때마다, `MyCenterWidget`과 `CounterWidget`이 매번 초기화된다(reinitialized). 이는 사실상 `CounterWidget`만 다시 빌드되면 되기 때문에 불필요한 동작이다.
- 이는 `InheritedWidget`으로 해결 가능하다.

# suepr 생성자
- super 생성자는 **부모 클래스의 생성자를 호출**하는 데 사용된다.
- 이를 통해 부모 클래스의 초기화 로직을 실행하고, 자식 클래스가 부모 클래스의 기능을 활용할 수 있다.
- 사용 이유
    1. **부모 클래스의 초기화 로직 실행**: 부모 클래스에서 정의된 필드나 동작을 올바르게 초기화하기 위해 필요하다.
    2. **부모 클래스에 필요한 매개변수 전달**: 부모 클래스 생성자가 요구하는 매개변수를 자식 클래스에서 받아 전달해야 한다.
    3. **Dart의 상속 구조**: Dart에서 자식 클래스가 부모 클래스를 상속하면, 부모 클래스의 생성자가 먼저 호출되어야 객체가 완전하게 초기화된다.
- 예제
    ```dart
    // 부모 클래스 정의
    class Parent {
      final String name;
    
      Parent(this.name); // Parent 클래스의 생성자
    }
    
    // 자식 클래스 정의
    class Child extends Parent {
      final int age;
    
      // Child 클래스 생성자에서 부모 클래스 생성자를 호출
      Child(String name, this.age) : super(name);
    
      void introduce() {
        print("My name is $name, and I am $age years old.");
      }
    }
    
    // 사용
    void main() {
      Child child = Child("Alice", 10);
      child.introduce(); // 출력: My name is Alice, and I am 10 years old.
    }
    
    ```
    - `Parent` 클래스는 `name` 필드를 초기화하는 생성자를 가진다.
    - `Child` 클래스는 `Parent`를 상속하며, `super(name)`를 통해 부모 생성자에 `name`을 전달한다.
- 따라서 **부모 클래스의 생성자가 요구하는 필수 매개변수는 자식 클래스에서 `super`를 통해 반드시 제공**해야 한다.    
    - 부모 클래스의 생성자가 객체를 초기화하는 데 필요한 필수 매개변수는, 부모 클래스가 정상적으로 동작하기 위해 반드시 값이 필요하다.
    - 따라서 따라서 자식 클래스에서 부모 클래스 생성자를 호출할 때, 해당 매개변수를 반드시 제공해야 한다.
- 반면, **부모 클래스에서 선택적으로 받는 매개변수(기본값이 있거나 nullable로 정의된 매개변수)는 자식 클래스에서 제공하지 않아도 된다.**

# InheritedWidget
- `InheritedWidget`은 위젯 트리의 하위[자식] 위젯들에게 데이터를 전달하는 역할을한다.
- InheritedWidget을 사용하면 데이터가 각 위젯을 거쳐 수동으로 전달될 필요 없이, 자식 위젯이 BuildContext를 통해 데이터를 직접 참조 및 접근할 수 있다.
![[InheritedWidget 구조.png|center|300]]
- 위 문제를 해결하기 위해 `InheritedWidget`을 상속 받는 클래스를 만들어보자.    
    ```dart
    class MyInheritedWidget extends InheritedWidget {
      /* 1. **InheritedWidget 클래스는 data provider(제공자)로서,**
        counter와 isLoading과 등, **자식 위젯에게 전달할 데이터를 포함해야 한다.** */
      final int counter;
      final bool isLoading;
      
      // 2. InheritedWidget을 상속받는 경우, **반드시 child 매개변수를 받는
      //    super 생성자를 호출해야 한다.**
      final Widget child;
      
      // 3. 이를 위해, **InheritedWidget이 전달할 데이터를 포함하고,
      //    child 매개변수를 처리하는 생성자**를 만들어야 한다.
      MyInheritedWidget({
        required this.isLoading,
        required this.counter,
        required this.child,
      }) : super(child: child);
    
      /* 4. InheritedWidget을 상속받는 경우,
            **반드시 updateShouldNotify 메서드를 오버라이드**해야 하며,
            이 메서드는 **새 데이터와 기존 데이터를 비교**해
            **위젯 트리의 업데이트 여부를 결정**한다. */
      @override
      bool updateShouldNotify(MyInheritedWidget oldWidget) {
        return false;
      }
    
      /* 5. 자식 위젯이 MyInheritedWidget에 접근하여 데이터를 가져가기 위해,
            **static으로 of 메서드를 제공**해야 한다. */
      static MyInheritedWidget? of(BuildContext context) {
        /* context.dependOnInheritedWidgetOfExactType<T>을 통해
           타입이 T인 가장 가까운 부모 위젯을 가져온다. */
        return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();
      }
    }
    ```
- `MyInheritedWidget`를 `CounterWidget`과 `MyCenterWidget`의 부모 위젯으로 등록해 준다. 그러면 더 이상 중복된 생성자를 위젯마다 작성해주지 않아도 된다.
    ```dart
    ...
    class MyHomePageState extends State<MyHomePage> {
      ...  
      @override
      Widget build(BuildContext context) {
        return Scaffold(
          body: MyInheritedWidget( // NEW
            isLoading: _isLoading,
            counter: _counter,
            child: MyCenterWidget(),
          ),
          ...
        );
      }
      ...
    }
    class CounterWidget extends StatelessWidget {
      @override
      Widget build(BuildContext context) {
        final myInheritedWidget = MyInheritedWidget.of(context); // NEW
        
        if (myInheritedWidget == null) {
          return Text('MyInheritedWidget was not found');
        }
        
        return myInheritedWidget.isLoading
            ? CircularProgressIndicator()
            : Text('${myInheritedWidget.counter}');
      }
    }
    ...
    ```
    1. `super(child)` 호출
        - `InheritedWidget` 생성자는 반드시 `child`를 필요로 합니다.
        - 자식 클래스 `MyInheritedWidget`은 생성자에서 `child`를 받아 `super(child: child)`로 부모 생성자에 전달합니다.
    2. `child`의 역할
        - 위젯 트리에서 하위 위젯 트리를 구성하며, 데이터를 전달받아 사용할 수 있습니다.
- 여기까지 하면 앞서 언급한 두 가지 문제 중, 똑같은 생성자를 여러 번 작성해야 되는 문제를 해결할 수 있다.
- 하지만 여전히 `CounterWidget`과 `MyCenterWidget`의 build 함수 안에 print문을 넣어 보면 버튼이 클릭될 때마다 print문이 찍히는 걸 확인할 수 있다.

# How to avoid unnecessary re-builds
- 버튼을 클릭할 때마다 `MyHomePage`의 `build` 함수 안에 있는 `setState` 함수가 호출된다.    
- 이에 따라 `CounterWidget`과 `MyCenterWidget`이 쓸데없이 다시 초기화된다(reinitialized).    
- 해결 방법    
    1. `MyHomePage` 클래스 안에 `Widget` 타입을 받는 `child` 속성을 만들어준 뒤, 해당 속성으로 `MyCenterWidget`의 인스턴스를 넘겨 준다.        
        ```dart
        void main() {
          runApp(
            MaterialApp(
              home: MyHomePage(
                isLoading: false,
                counter: 0,
                **child: MyCenterWidget(), // NEW**
              ),
            ),
          );
        }
        class MyHomePage extends StatefulWidget {
          final bool isLoading;
          final int counter;
          **final Widget child;  // NEW**
          
          const MyHomePage({
            required this.isLoading,
            required this.counter,
            **required this.child,  // NEW**
          });
        ...
        }
        ```
    2. `MyCenterWidget`의 인스턴스를 `child` 속성에 넘겨줬기 때문에 더 이상 추가적인 `MyCenterWidget` 인스턴스를 만들 필요 없이 해당 인스턴스를 `widget` 변수로 `MyHomePage`로 넘겨주면 된다.

        ```dart
        class MyHomePageState extends State<MyHomePage> {
        ...
          @override
          Widget build(BuildContext context) {
            return Scaffold(
              body: MyInheritedWidget(
                isLoading: _isLoading,
                counter: _counter,
                **child: widget.child,          // NEW**
              ),
              ...
            );
          }
        ...
        }
        ```
- 여기까지 진행하면 `CounterWidget`과 `MyCenterWidget`의 build 함수가 계속 호출되진 않지만, UI가 바뀌지 않는 심각한 문제가 발생한다.

# updateShouldNotify method
- `updateShouldNotify` 함수는 `InheritedWidget`이 다시 빌드된(rebuilt) 직후에 호출된다.
- 만약 `updateShouldNotify`가 `true`를 반환하면, `InheritedWidget`이 다시 빌드된 이후 해당 위젯에 의존하는 자식 위젯들이 강제로 다시 빌드된다.
    - 한 가지 강조할 부분은 `updateShouldNotify`는 오직 `InheritedWidget`을 **직접 참조**하는 위젯(`MyInheritedWidget.of(context)`)에만 영향을 준다는 점이다.
    - 현재 코드에서 `MyInheritedWidget`을 직접 참조하는 위젯은 `CounterWidget`만 해당된다.
- 반대로, `updateShouldNotify`가 `false`를 반환하면, 어떠한 자식 위젯도 다시 빌드되지 않는다.
- 여기서 ‘의존한다’는 것은, `MyInheritedWidget.of(context)` 함수를 호출하는 `MyInheritedWidget`의 자식 위젯들이 부모 위젯인 `MyInheritedWidget`에 '의존한다'고 할 수 있다.
- 즉 현재 `updateShouldNotify`가 `false`을 반환하기 때문에 자식 위젯인 `CounterWidget`이 `build` 함수를 다시 호출하지 못하고 있는 상황이었던 것이다.
- 따라서 `updateShouldNotify`가 `true`를 반환하도록 코드를 수정하되, 데이터를 체크해서 build 함수 호출이 필요할 때만 `true`를 반환하도록 코드를 작성해 준다.
    ```dart
    @override
    bool updateShouldNotify(MyInheritedWidget oldWidget) {
       return isLoading != oldWidget.isLoading || counter != oldWidget.counter;
    }
    ```

# Comparison and Conclusion
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: MyHomePage(isLoading: false, counter: 0),
    ),
  );
}

class MyHomePage extends StatefulWidget {
  final bool isLoading;
  final int counter;

  const MyHomePage({
    required this.isLoading,
    required this.counter,
  });

  @override
  State<MyHomePage> createState() {
    return MyHomePageState();
  }
}

class MyHomePageState extends State<MyHomePage> {
  late bool _isLoading;
  late int _counter;

  @override
  void initState() {
    super.initState();
    _isLoading = widget.isLoading;
    _counter = widget.counter;
  }

  @override
  Widget build(BuildContext context) {
    print('rebuild MyHomePage');
    return Scaffold(
      body: MyInheritedWidget(
        isLoading: _isLoading,
        counter: _counter,
        child: MyCenterWidget(),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: onFloatingButtonClicked,
      ),
    );
  }

  void onFloatingButtonClicked() {
    print('Button clicked!. Call setState method');
    setState(() {
      _counter++;
      if (_counter % 2 == 0) {
        _isLoading = false;
      } else {
        _isLoading = true;
      }
    });
  }
}

class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    print('rebuild CounterWidget');
    final myInheritedWidget = MyInheritedWidget.of(context);

    if (myInheritedWidget == null) {
      return Text('MyInheritedWidget was not found');
    }

    return myInheritedWidget.isLoading
        ? CircularProgressIndicator()
        : Text('${myInheritedWidget.counter}');
  }
}

class MyCenterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    print('rebuild MyCenterWidget');
    return Center(
      child: CounterWidget(),
    );
  }
}

class MyInheritedWidget extends InheritedWidget {
  final int counter;
  final bool isLoading;
  final Widget child;

  MyInheritedWidget({
    required this.isLoading,
    required this.counter,
    required this.child,
  }) : super(child: child);

  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    return false;
  }

  static MyInheritedWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();
  }
}

```
```dart
import 'package:flutter/material.dart';

void main() {
  runApp(
    MaterialApp(
      home: MyHomePage(
        isLoading: false,
        counter: 0,
        **child: MyCenterWidget(), // NEW**
      ),
    ),
  );
}

class MyHomePage extends StatefulWidget {
  final bool isLoading;
  final int counter;
  **final Widget child; // NEW**

  const MyHomePage({
    required this.isLoading,
    required this.counter,
    **required this.child, // NEW**
  });

  @override
  State<MyHomePage> createState() {
    return MyHomePageState();
  }
}

class MyHomePageState extends State<MyHomePage> {
  late bool _isLoading;
  late int _counter;

  @override
  void initState() {
    super.initState();
    _isLoading = widget.isLoading;
    _counter = widget.counter;
  }

  @override
  Widget build(BuildContext context) {
    print('rebuild MyHomePage');
    return Scaffold(
      body: MyInheritedWidget(
        isLoading: _isLoading,
        counter: _counter,
        **child: widget.child, // CHANGED**
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: onFloatingButtonClicked,
      ),
    );
  }

  void onFloatingButtonClicked() {
    print('Button clicked!. Call setState method');
    setState(() {
      _counter++;
      if (_counter % 2 == 0) {
        _isLoading = false;
      } else {
        _isLoading = true;
      }
    });
  }
}

class CounterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    print('rebuild CounterWidget');
    final myInheritedWidget = MyInheritedWidget.of(context);

    if (myInheritedWidget == null) {
      return Text('MyInheritedWidget was not found');
    }

    return myInheritedWidget.isLoading
        ? CircularProgressIndicator()
        : Text('${myInheritedWidget.counter}');
  }
}

class MyCenterWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    print('rebuild MyCenterWidget');
    return Center(
      child: CounterWidget(),
    );
  }
}

class MyInheritedWidget extends InheritedWidget {
  final int counter;
  final bool isLoading;
  final Widget child;

  MyInheritedWidget({
    required this.isLoading,
    required this.counter,
    required this.child,
  }) : super(child: child);

  @override
  bool updateShouldNotify(MyInheritedWidget oldWidget) {
    **return isLoading != oldWidget.isLoading || counter != oldWidget.counter; // CHANGED**
  }

  static MyInheritedWidget? of(BuildContext context) {
    return context.dependOnInheritedWidgetOfExactType<MyInheritedWidget>();
  }
}

```
- 각 코드의 출력 차이
    ```dart
    rebuild MyHomePage
    rebuild MyCenterWidget
    rebuild CounterWidget
    Button clicked!. Call setState method
    rebuild MyHomePage
    rebuild MyCenterWidget
    rebuild CounterWidget
    Button clicked!. Call setState method
    rebuild MyHomePage
    rebuild MyCenterWidget
    rebuild CounterWidget
    ```
    ```dart
    rebuild MyHomePage
    rebuild MyCenterWidget
    rebuild CounterWidget
    Button clicked!. Call setState method
    rebuild MyHomePage
    rebuild CounterWidget
    Button clicked!. Call setState method
    rebuild MyHomePage
    rebuild CounterWidget
    ```
- 첫 번째 코드와 두 번째 코드 모두 위젯 계층 구조는 동일하다.
    - 첫 번째 코드는 `MyHomePage`에서 `setState`가 호출될 때마다 `Scaffold`의 `body` 전체가 다시 빌드되면서 `MyCenterWidget`과 `CounterWidget`도 다시 빌드되는 구조이다.
    - 두 번째 코드에서는 `MyInheritedWidget`의 `updateShouldNotify`가 상태 변화(`_counter`, `_isLoading`)에 따라 `true`를 반환한다.
    - `MyInheritedWidget`이 변경되면 Flutter는 `context.dependOnInheritedWidgetOfExactType`을 통해 해당 위젯, 즉 `InheritedWidget`을 상속받은 클래스만 업데이트한다.
    - `CounterWidget`은 `MyInheritedWidget`에 의존하므로 상태 변화 시 다시 빌드된다.
- `InheritedWidget`은 상태 관리 방법 중 하나로, 더 복잡한 상태 관리 접근법이 궁금하다면 ‘[Provider](https://pub.dev/packages/provider)’ and ‘[Bloc](https://pub.dev/packages/flutter_bloc)’과 같은 방법을 찾아보자.    
    - `Provider`는 `InheritedWidget`의 확장된 형태로, 상태 관리 및 의존성 주입을 더 쉽게 할 수 있도록 도와준다.
    - 따라서 `InheritedWidget`을 이해하면 `Provider`의 동작 방식을 더 쉽게 익힐 수 있다.