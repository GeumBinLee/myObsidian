> [!Info]- 출처 링크
> [🔗 Flutter Zero to Hero.Part 5 🔗](https://medium.com/@NALSengineering/flutter-from-zero-to-hero-part-5-understand-how-flutter-works-in-4-minutes-1a3fbd834c0d)

> [!Question] 학습 목표
> 클래스 `Element`와 플러터의 작동 원리

# `Widget` & `Element` & `RenderObject`
> [!Quote] *Element*란,**트리 내 특정 위치에서 위젯이 인스턴스화된 것**이다.
- Widget은 종종 설계도로 비유되곤 한다. 위젯은 UI의 한 부분에 대한 설정을 담고 있으며, 요소(Element)는 그 설계도를 바탕으로 실제로 생성된 UI의 한 조각을 나타낸다.
- Element가 직접 UI를 그리는 건 아니고, RenderObject가 실제 UI를 그린다.
- `RenderObject`는 UI의 크기, 레이아웃, 그리고 그리기 과정을 담당하는 렌더링 객체와 같다.
- 요약
	![[Widget, Element, RenderObject 간 관계.png|center|400]]
	1. Widget은 청사진으로, UI의 설정[구성 정보]을 담고 있다.
	2. Renderobject는 builder로써 UI의 크기, 레이아웃, 그리고 그리기 과정을 제어한다.
	3. Element는 관리자로서 **Widget**과 **RenderObject**의 참조를 유지하며 UI 빌드 과정을 관리한디.

# `Widget` & `Element` & `RenderObject` 자세히보기
- Flutter 아키텍처에서 Widget, Element, RenderObject의 역할
    - Widget
        - 설계도 역할(구성 정보만 포함)
        - 불변 객체(상태를 가지지 않음)
    - Element
        - Widget의 인스턴스화된 형태로, Widget과 RenderObject를 연결하고 상태를 관리한다.
        - 트리 내에서 Widget과 RenderObject의 관계를 유지하며, 업데이트가 필요한 경우 이를 처리한다.
    - RenderObject
        - UI를 실제로 그리는 객체
        - 크기, 레이아웃, 그리고 그리기를 담당하며, Element의 요청에 따라 작동한다.
- 연결 구조
    - **Widget → Element**
        - `Element`는 Widget을 참조하여 UI의 구조와 데이터를 이해한다.
        - Element는 Widget이 변경될 때 새 Widget과 기존 Widget을 비교(diff)하여 필요한 업데이트를 수행한다.
    - **Element → RenderObject**
        - `Element`는 필요한 경우 **RenderObject를 생성**하고, 이를 참조한다.
        - RenderObject가 크기, 레이아웃, 그리기 등을 처리하도록 관리한다.
    - **Widget과 RenderObject는 직접적으로 연결되지 않는다.**
        - Widget은 RenderObject에 대한 정보를 알지 못한다.
        - RenderObject는 Widget의 존재를 알지 못한다.
        - Element가 이 둘을 연결하며 업데이트 과정을 조정한다.
- 예시
    ```dart
    Widget (설계도)
       ↓
    Element (연결 및 상태 관리)
       ↓
    RenderObject (실제 렌더링 수행)
    ```
    - **Widget**: "이 버튼은 파란색이고, 크기는 100x50입니다."
    - **Element**: "알겠습니다! 새 RenderObject를 만들고 이 설정을 전달하겠습니다."
    - **RenderObject**: "전달받은 설정대로 UI를 렌더링하겠습니다."
- 요약
    - Widget과 RenderObject는 직접 연결되지 않고, Element가 중간에서 이를 연결한다.
    - **Element는 Widget의 상태를 관리하며, RenderObject를 생성하고 업데이트하는 역할을 담당**합니다.
    - 이 구조는 Flutter가 효율적으로 UI를 빌드하고 업데이트하도록 설계된 핵심 개념이다.

# The ElementTree
- `runApp` 함수에 위젯 트리를 전달하면, Flutter는 해당 트리를 루트 위젯부터 시작해 순회한다.
- 이때 위젯 트리 내 각 위젯은 element tree의 각 element에 매핑된다.
- StatelessWidget은 StatelessElement를 만들고, StatefulWidget은 StatefuElement를 만든다.
	![[위젯 트리와 엘레멘트 트리 1.png|center|500]]
- 앞서 언급했듯, 각 엘레멘트는 위젯에 대한 참조를 갖는다.
- 예를 들어, 어떤 `Element` 클래스의 코드를 보면, `Widget` 타입의 속성이 존재한다.
    ```dart
    class Element {
      Element(Widget widget) : _widget = widget;
    
      Widget? _widget;
    }
    ```
    - 이 `widget` 변수는 `final`이 아니므로, **Element 클래스는 변경 가능(mutable)**하며, 따라서 **Element 객체는 업데이트될 수 있다**.
- `StatefulElement`는 조금 특이한데, `StatefulWidget`에 대한 참조를 가지고있을 뿐만 아니라, `state` 변수를 통해 `State<StatefulWidget>` 객체에 대한 참조도 유지한다.    
- 이는 `StatefulElement`의 생성자를 살펴보면 명확히 알 수 있다.
    ```dart
    class StatefulElement extends ComponentElement {
      StatefulElement(StatefulWidget widget)
          : _state = widget.createState(), // HERE  
      State<StatefulWidget>? _state; // HERE
    }
    ```
- 요약 - Widget Tree, Eelement Tree, State Object 간의 관계
    ![[위젯 트리와 엘레멘트 트리 2.png|center|500]]
    1. **StatefulElement**는 **StatefulWidget**과 **State**에 대한 참조를 가지고 있다.
    2. 반면, **StatelessElement**는 **StatelessWidget**에 대한 참조만 가지고 있다.

# How Flutter renders Widgets
- 위젯이 다시 빌드될 때마다, Element는 현재 참조하고 있는 이전 위젯 객체와 새로 생성된 위젯 객체를 비교한다.
- 만약 이전 위젯과 **새 위젯이 동일한 타입**(e.g. 둘 다 `CounterWidget`)**이라면, element는 참조를 새 위젯으로 업데이트하고 이전 위젯에 대한 참조를 제거**한다.
- 다른 타입일 때는 Flutter가 **기존의 `Element`를 제거하고, 새로운 위젯 타입에 맞는 `Element`를 생성**한다.
![[위젯 트리와 엘레멘트 트리 3.png|center|500]]
- 이는 위젯이 지속적으로 인스턴스화되더라도 Flutter가 따르는 원칙이다.
- 새로운 Eelement는 실제 UI를 나타내고, UI의 일부를 나타내며, 자주 인스턴스화되지 않고 대신 업데이트 된다. 이것이 Eelement 클래스가 변경 가능한(mutable) 이유이기도 하다.
- 그렇다면 `Eelement`는 언제 인스턴스화될까? 바로 이전 위젯과 새 위젯의 타입이 다를 때다.
- 이전 위젯의 타입이 새 위젯의 타입과 다를 경우, 해당 위치에서 새 위젯이 `createElement` 함수를 호출하여 새로운 Element를 생성한다.
- 이로 인해 전체 하위 Element Tree가 새로 인스턴스화되며, 이는 성능에 큰 부담을 줄 수 있다.
- 이는 성능에 부하를 줄 수 있기 때문에, `Eelement`를 인스턴스화하는 건 피하는 게 좋다.

# Example
```dart
class CounterWidget extends StatelessWidget {
  ...
  @override
  StatelessElement createElement() {
    print('createElement CounterWidget');
    return super.createElement();
  }
  ...
}
```
- `createElement` 함수는 app이 실행(run)되고 나서 호출된다.    
    ```dart
    rebuild MyHomePage
    createElement CounterWidget
    rebuild CounterWidget
    ```
- 버튼을 누르고 나서 `CounterWidget`이 다시 build 되어도, `createElement` 함수는 다시 호출되지 않는다. 이전 위젯과 새 위젯이 동일한 `CounterWidget` 위젯을 공유하기 때문이다.    
    ```dart
    Button clicked!. Call setState method 
    rebuild MyHomePage 
    rebuild CounterWidget
    ```    
- 위젯이 다시 빌드될 때 Element가 인스턴스화되게 하기 위해 코드를 아래와 같이 수정해보자.
    ```dart
    ...
    body: Center(
      child: _isLoading
          ? CircularProgressIndicator()
          : CounterWidget(
              isLoading: _isLoading,
              counter: _counter,
            ),
    ),
    ...
    ```
    - `_isLoading`가 `true`일 때, `CounterWidget`의 위치는 `CounterWidget`과는 다른 타입의 `CircularProgressIndicator`로 대체된다. 두 위젯의 타입이 다르기 때문에 Element가 인스턴스화된다.
- 버튼을 처음 눌렀을 때는 `_isLoading` 이 `true`고, `CounterWidget`이 다시 빌드되지 않았기 때문에 아래와 같은 로그가 출력된다.
    ```dart
    Button clicked!. 
    Call setState method rebuild MyHomePage
    ```    
- 버튼을 다시 눌렀을 때 `_isLoading`이 `false`로 바뀌고, `CounterWidget`이 다시 build됨에 따라 `CounterElement`가 인스턴스화 되며 아래의 로그가 출력된다.
    ```dart
    Button clicked!. Call setState method 
    rebuild MyHomePage 
    createElement CounterWidget // HERE 
    rebuild CounterWidget
    ```

# Conclusion
- 우리는 Element가 언제 업데이트 되는지, Element가 트리를 타고 내려가 이전 위젯과 새 위젯의 `Type`을 비교해 언제 인스턴스화되는지에 대해서 배웠다.
- 사실 타입뿐만 아니라 `Key`라고 불리는 것도 비교한다. 다음 시간에는 `Key`에 대해서 알아볼 것이다.

# 비교 in detail
> [!Info]
> 즉, 위젯의 **상태가 바뀔 때는 엘레멘트가 업데이트** 되고, **위젯이 아예 다른 걸로 바뀔 때 엘레멘트가 새로 인스턴스화** 된다.
## 위젯의 상태가 바뀔 때 → Element 업데이트
- 위젯 *타입이 동일할 경우*
	- *기존 `Element`가 그대로 유지된다.*
	- *Flutter는 새로운 위젯 객체와 기존 위젯 객체를 비교(`diffing`)하여 필요한 속성만 업데이트한다.*
	- *기존 `Element`의 `Widget` 참조가 새로운 위젯으로 업데이트된다.*
	- *결과적으로 **트리 구조는 유지**되고, 렌더링에 필요한 최소한의 변경만 발생한다.*
- *예시 - < **동일한 타입 → Element 업데이트** >*
	```dart
	@override
	Widget build(BuildContext context) {
	  print('rebuild MyHomePage');
	  return Scaffold(
		body: Center(
		  **child: CounterWidget(
			isLoading: _isLoading,
			counter: _counter,
		  ),**
		),
		floatingActionButton: FloatingActionButton(
		  onPressed: onFloatingButtonClicked,
		),
	  );
	}
	```
	- *위젯 타입은 항상 `CounterWidget`이다.*
	- *`_counter`나 `_isLoading` 값이 바뀌어도 기존 `Element`가 업데이트된다.*
	- *새로운 `El*ement`는 생성되지 않는다.
## 위젯이 아예 다른 걸로 바뀔 때 → Element 새로 인스턴스화
- 위젯 타입이 변경될 경우
	- Flutter는 기존 `Element`를 제거하고, 새로운 `Element`를 생성한다.
	- 이로 인해 해당 위치에서 하위 트리 전체가 새로 빌드된다.
	- 이는 성능상 이점이 된다.
- 예시 - < **다른 타입 → Element 새로 인스턴스화** >
	```dart
	@override
	Widget build(BuildContext context) {
	  print('rebuild MyHomePage');
	  return Scaffold(
		body: Center(
		  **child: _isLoading
			  ? CircularProgressIndicator()
			  : CounterWidget(
				  isLoading: _isLoading,
				  counter: _counter,
				),**
		),
		floatingActionButton: FloatingActionButton(
		  onPressed: onFloatingButtonClicked,
		),
	  );
	}
	```
## 차이점 요약

| 상황           | Element 처리 방식    | 설명                                 |
| ------------ | ---------------- | ---------------------------------- |
| 위젯의 상태가 바뀔 때 | Element 업데이트     | 기존 `Element`를 재사용하며 필요한 속성만 업데이트   |
| 위젯 타입이 변경될 때 | Element 새로 인스턴스화 | 기존 `Element`를 제거하고 새 `Element`를 생성 |
-  **위젯의 상태 변화는 Element가 업데이트**되며 **성능적으로 효율적**이다.
- **위젯 타입 변경은 Element가 새로 생성되어 성능에 부담**을 줄 수 있으므로, 가능하다면 동일한 타입의 위젯을 재사용하는 방식으로 설계하는 것이 좋다.